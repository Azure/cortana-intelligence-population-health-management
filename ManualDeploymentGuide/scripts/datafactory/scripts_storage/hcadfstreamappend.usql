// 
// Copyright  Microsoft Corporation ("Microsoft").
// 
// Microsoft grants you the right to use this software in accordance with your subscription agreement, if any, to use software 
// provided for use with Microsoft Azure ("Subscription Agreement").  All software is licensed, not sold.  
// 
// If you do not have a Subscription Agreement, or at your option if you so choose, Microsoft grants you a nonexclusive, perpetual, 
// royalty-free right to use and modify this software solely for your internal business purposes in connection with Microsoft Azure 
// and other Microsoft products, including but not limited to, Microsoft R Open, Microsoft R Server, and Microsoft SQL Server.  
// 
// Unless otherwise stated in your Subscription Agreement, the following applies.  THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT 
// WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL MICROSOFT OR ITS LICENSORS BE LIABLE 
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED 
// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE SAMPLE CODE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// 

/* Summary:
 Data for PBI visualization consists of all streamed scored data (received after externally defined @dataAquisitionStart), padded 
with historic data up to @dataSizeForVisualization rows. If all streamed scored data has more than @dataSizeForVisualization rows,
we only keep the most recent @dataSizeForVisualization streamed scored rows and append 0 historical rows.

@dataAquisitionStart is a variable defined by activities parameters of the adf pipeline json definition (source).

 Inputs:
  - all streamed scored data received after @dataAquisitionStart
  - historic data (1103173 rows)
  
 Output:
   - most recent up to @dataSizeForVisualization rows from scored streamed data, concatenated with historic data if needed.
  
*/

REFERENCE ASSEMBLY [ExtR];

// number of rows used for PBI visualization
DECLARE @dataSizeForVisualization int = 1000000;

// define input data, all streamed scored (received after externally defined @dataAquisitionStart) plus historic data
DECLARE @HistoricalDataFile string =  @"/PHM/data/historical/data_for_visualization_useful_columns_historical.csv";
DECLARE @inputFile string = "/stream/forPBI/{scoredStreamedSubsettingDate:yyyy}/{scoredStreamedSubsettingDate:MM}/{scoredStreamedSubsettingDate:dd}/{scoredStreamedSubsettingDate:HH}/{scoredStreamedSubsettingDate:mm}_forPBI.csv";

// define all streamed scored data
@InputDataAll = 
    EXTRACT 
	dateAndTime DateTime,
	dshospid string,
	id string,
	age string,
	amonth string,
	atype string,
	dispub04 string,
	drg string,
	dx1 string,
	dxccs1 string,
	hospst string,
	homeless string,
	los string,
	mdc string,
	medincstq string,
	pr1 string,
	prccs1 string,
	pstate string,
	pointoforiginub04 string,
	race string,
	totchg string,
	visitlink string,
	zip string,
	ayear string,
	dxmccs1 string,
	prmccs1 string,
	readmitted string,
	dxccs_name string,
	prccs_name string,
	prmccs_name string,
	dxmccs_name string,
	transfer_in string,
	mdc_name string,
	totchg_bin string,
	los_bin string,
	chgperday string,
	age_bin string,
	age_bin2 string,
	payer1 string,
	gender string,
	hospzip string,
	readmitted_num string,
	myrownum string,
	ecol1 string,
	ecol2 string,
	ecol3 string,
	ecol4 string,
	ecol5 string,
	ecol6 string,
	ecol7 string,
	chronic_conditions string,
	ecol8 string,
	ecol9 string,
	ecol10 string,
	readmittance_conditions string,
	scoredStreamedSubsettingDate DateTime 
    FROM @inputFile
    USING Extractors.Csv();  

// load all streamed scored data received since @dataAquisitionStart    
 @InputData = 
    SELECT   *
    FROM @InputDataAll
    WHERE scoredStreamedSubsettingDate >= DateTime.Parse(@dataAquisitionStart);    

// load historical data to pad streamed scored up to @dataSizeForVisualization        
@HistoricalData =
     EXTRACT 
	dshospid string,
	id string,
	age string,
	amonth string,
	atype string,
	dispub04 string,
	drg string,
	dx1 string,
	dxccs1 string,
	hospst string,
	homeless string,
	los string,
	mdc string,
	medincstq string,
	pr1 string,
	prccs1 string,
	pstate string,
	pointoforiginub04 string,
	race string,
	totchg string,
	visitlink string,
	zip string,
	ayear string,
	dxmccs1 string,
	prmccs1 string,
	readmitted string,
	dxccs_name string,
	prccs_name string,
	prmccs_name string,
	dxmccs_name string,
	transfer_in string,
	mdc_name string,
	totchg_bin string,
	los_bin string,
	chgperday string,
	age_bin string,
	age_bin2 string,
	payer1 string,
	gender string,
	hospzip string,
	readmitted_num string,
	myrownum string,
	ecol1 string,
	ecol2 string,
	ecol3 string,
	ecol4 string,
	ecol5 string,
	ecol6 string,
	ecol7 string,
	chronic_conditions string,
	ecol8 string,
	ecol9 string,
	ecol10 string,
	readmittance_conditions string
    FROM @HistoricalDataFile
    USING Extractors.Csv();

// select the most recent @dataSizeForVisualization rows from streamed data  
// add RowNumber columns to be in sync with ordered historical data so that we can eventually concatenate
@scoredStreamedData = 
    SELECT 
    ROW_NUMBER() OVER(ORDER BY dateAndTime ASC) AS RowNumber,
    *,    
    ROW_NUMBER() OVER(ORDER BY dateAndTime ASC) AS myRowCount
    FROM @InputData
    ORDER BY dateAndTime ASC
    FETCH @dataSizeForVisualization ROWS;   

// if we did not stream @dataSizeForVisualization rows yet, fill the balance using historic data 
// add row number info based on streamed records time to ease selection of most recent scored streamed data     
@numberedHistoricalData =
    SELECT 
    ROW_NUMBER() OVER(ORDER BY id ASC) AS RowNumber,
    DateTime.Parse("2010-05-02T13:00:19.4414536") AS dateAndTime,
    *,
    DateTime.Parse("2010-05-02T13:00:19.4414536") AS scoredStreamedSubsettingDate
    FROM @HistoricalData;

// name 'myRowCount' will appear as last column in next join query
@scoredStreamedDataInfo = SELECT COUNT(*)  AS myRowCount FROM @scoredStreamedData;

// now select historical data rows to fill up to @dataSizeForVisualization rows
@remainingData = 
    SELECT *
    FROM @numberedHistoricalData
    CROSS JOIN @scoredStreamedDataInfo AS crtscoredStreamedDataInfo
    WHERE @numberedHistoricalData.RowNumber <= (@dataSizeForVisualization-crtscoredStreamedDataInfo.myRowCount) ;

// put together scored streamed data we got so far, plus historic data, in a @dataSizeForVisualization rows long rowset
 @concatenatedData =    
     SELECT * FROM @scoredStreamedData
     UNION ALL         
     SELECT * FROM @remainingData;  
     
// final data has same schema as historical data (i.e. streamed scored data minus dateAndTime), so we remove all time and row info and virtual columns    
@finalData = 
    SELECT 
	dshospid,
	id,
	age,
	amonth,
	atype,
	dispub04,
	drg,
	dx1,
	dxccs1,
	hospst,
	homeless,
	los,
	mdc,
	medincstq,
	pr1,
	prccs1,
	pstate,
	pointoforiginub04,
	race,
	totchg,
	visitlink,
	zip,
	ayear,
	dxmccs1,
	prmccs1,
	readmitted,
	dxccs_name,
	prccs_name,
	prmccs_name,
	dxmccs_name,
	transfer_in,
	mdc_name,
	totchg_bin,
	los_bin,
	chgperday,
	age_bin,
	age_bin2,
	payer1,
	gender,
	hospzip,
	readmitted_num,
	myrownum,
	ecol1,
	ecol2,
	ecol3,
	ecol4,
	ecol5,
	ecol6,
	ecol7,
	chronic_conditions,
	ecol8,
	ecol9,
	ecol10,
	readmittance_conditions 
    FROM @concatenatedData;

// save final data
OUTPUT @finalData TO @outputFile USING Outputters.Csv(quoting : false);




